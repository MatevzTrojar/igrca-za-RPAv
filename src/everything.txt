#include "Bullet.hpp"
#include <algorithm>
#include "Game.h"
#include "clock.hpp" 
#include <cmath>
#include <csignal>
#include <ctime>
#include <exception>
#include <fstream>
#include <sstream>
#include <vector>
#include "GameObject.h"
#include "SDL_stdinc.h"
#include "glm/common.hpp"
#include "glm/ext/vector_float2.hpp"
void Bullet::Update(GameObject *player) {
    posx+=pos.x *Clock::delta;
    posy+=pos.y * Clock::delta;
    dest.x = posx - Game::Camera.x; 
    dest.y =posy - Game::Camera.y;
    if(posx > Game::Camera.x + 1920){
        Active = false;
    }
    if(posy>Game::Camera.y + 1080)
        Active = false;
    if(posx< -Game::Camera.x)
        Active = false;
    if(posy< -Game::Camera.y)
        Active = false;

}
#include <sys/types.h>
#include <cstdio>
#include <vector>
#include "Game.h"
#include "GameObject.h"
#include "SDL_gesture.h"
#include "SDL_render.h"
#include "SDL_stdinc.h"
#include "SDL_timer.h"
#include "TextureManager.h"
#include "glm/common.hpp"
#include "glm/ext/vector_float2.hpp"
#include <set>
#include "Scientist.hpp"

class Bullet : public GameObject {
   public:
	Bullet(const char* textureSheet, int x, int y,int h ,int w): GameObject(textureSheet, x, y, h, w){                                                                        

	};
    glm::vec2 pos;
    int firerate = 3000;
	~Bullet(){
    //    Clean();
    };
	void Update(GameObject *player);
    bool Active = false;
    };


    #include "Game.h"

#include <SDL_ttf.h>
#include <climits>
#include <cstddef>
#include <cstdlib>
#include <fstream>
#include <glm/glm.hpp>
#include <iomanip>
#include <ios>
#include <iostream>
#include <set>
#include <vector>

#include "Bullet.hpp"
#include "Collision.hpp"
#include "GameObject.h"
#include "Mouse.hpp"
#include "SDL_blendmode.h"
#include "SDL_events.h"
#include "SDL_log.h"
#include "SDL_mutex.h"
#include "SDL_rect.h"
#include "SDL_render.h"
#include "SDL_stdinc.h"
#include "Scientist.hpp"
#include "TextureManager.h"
#include "glm/detail/type_half.hpp"
#include "player.hpp"
int SCREEN_WIDTH = 1920;
int SCREEN_HEIGHT = 1080;
std::set<Bullet*> bullets;
Player* player;
GameObject* Level1Pet;
GameObject* Level2Pet;
GameObject* Level3Pet;
std::set<Scientist*> scientists;
Mouse mouse;
Map* map;
SDL_Rect Game::Camera = {0, 0, 1920, 1080};
int life = 3;
SDL_Renderer* Game::renderer = nullptr;
SDL_Renderer* PauseRenderer = nullptr;
bool isInnitialized = false;
bool Game::overworld = true;
bool Game::victory = false;
bool Game::gameOver = false;
bool Game::MainMenu = true;
bool Game::EndGame = false;
bool Game::Paused = false;
int Game::level = 0;
TTF_Font* pauseFont = nullptr;

void Game::RestartGame() {
    if (Level1Pet) {
        delete Level1Pet;
        Level1Pet = nullptr;
    }
    if (Level2Pet) {
        delete Level2Pet;
        Level2Pet = nullptr;
    }
    if (Level3Pet) {
        delete Level3Pet;
        Level3Pet = nullptr;
    }
    victory = false;
    gameOver = false;
    Paused = false;
    life = 3;
    if (!overworld) {
        overworld = true;
        Overworldinit();
    }
    level = 0;
    for (int x = 0; x < 120; x++) {
        for (int y = 0; y < 72; y++) {
            map->tile[x][y].Used = false;
        }
    }
    scientists.clear();
}

void Game::ContinueGame() {
    victory = false;
    gameOver = false;
    overworld = true;
    EndGame = false;
    Overworldinit();
}

struct SaveData {
    int level;
    int life;
    bool overworld;
    bool victory;
    bool gameOver;
    bool EndGame;
    int PetCount;
    bool Follow1, Follow2, Follow3;
};

void Game::SaveGame() {
    std::ofstream SaveFile("Saving.bin", std::ios::binary);
    if (!SaveFile) {
        std::cerr << "Error opening file for saving." << std::endl;
        return;
    }
    SaveData data;
    data.level = level;
    data.life = life;
    data.overworld = overworld;
    data.victory = victory;
    data.gameOver = gameOver;
    data.EndGame = EndGame;
    data.Follow1 = Level1Pet ? Level1Pet->Follow : false;
    data.Follow2 = Level2Pet ? Level2Pet->Follow : false;
    data.Follow3 = Level3Pet ? Level3Pet->Follow : false;
    if (overworld)
        data.PetCount = (Level1Pet != nullptr) + (Level2Pet != nullptr) +
                        (Level3Pet != nullptr);
    else
        data.PetCount = 0;

    SaveFile.write(reinterpret_cast<const char*>(&data), sizeof(SaveData));
    if (overworld) {
        SaveObjectData saveData;
        if (Level1Pet) {
            // GetSaveData() should now also return shelter coordinates.
            saveData = Level1Pet->GetSaveData();
            SaveFile.write(reinterpret_cast<char*>(&saveData), sizeof(saveData));
        }
        if (Level2Pet) {
            saveData = Level2Pet->GetSaveData();
            SaveFile.write(reinterpret_cast<char*>(&saveData), sizeof(saveData));
        }
        if (Level3Pet) {
            saveData = Level3Pet->GetSaveData();
            SaveFile.write(reinterpret_cast<char*>(&saveData), sizeof(saveData));
        }
    }

    SaveFile.close();
    std::cout << "Level: " << level << std::endl;
    std::cout << "Life: " << life << std::endl;
    std::cout << "Overworld: " << overworld << std::endl;
    std::cout << "Victory: " << victory << std::endl;
    std::cout << "GameOver: " << gameOver << std::endl;
    std::cout << "EndGame: " << EndGame << std::endl;
}

bool Game::Loaded = false;
void Game::LoadGame() {
    Loaded = true;
    std::ifstream LoadFile("Saving.bin", std::ios::binary);
    if (!LoadFile) {
        std::cerr << "Error opening file for loading." << std::endl;
        return;
    }
    SaveData data;
    LoadFile.read(reinterpret_cast<char*>(&data), sizeof(SaveData));
    level = data.level;
    life = data.life;
    overworld = data.overworld;
    victory = data.victory;
    gameOver = data.gameOver;
    EndGame = data.EndGame;
    
    if (overworld) {
        // Updated lambda now creates the pet using saved coordinates.
        auto loadPet = [&](GameObject*& pet, bool followState, const char* texture) {
            SaveObjectData petData;
            if (!LoadFile.read(reinterpret_cast<char*>(&petData), sizeof(petData))) {
                std::cerr << "Failed to read pet data!" << std::endl;
                return;
            }
            // Create the pet using the saved position from petData.
            pet = new GameObject(texture, petData.posx, petData.posy, 64, 64);
            pet->SetSaveData(petData); // This should restore position, shelterX, shelterY, etc.
            pet->Follow = followState;
            pet->ResetAnimation();
        };

        if (data.PetCount >= 1)
            loadPet(Level1Pet, data.Follow1, "assets/textures/animated_pet.png");
        if (data.PetCount >= 2)
            loadPet(Level2Pet, data.Follow2, "assets/textures/animated_pet.png");
        if (data.PetCount >= 3)
            loadPet(Level3Pet, data.Follow3, "assets/textures/animated_pet.png");
    }
    LoadFile.close();
    std::cout << "Level: " << level << std::endl;
    std::cout << "Life: " << life << std::endl;
    std::cout << "Overworld: " << overworld << std::endl;
    std::cout << "Victory: " << victory << std::endl;
    std::cout << "GameOver: " << gameOver << std::endl;
    std::cout << "EndGame: " << EndGame << std::endl;
    if (overworld) {
        Overworldinit();
    } else {
        Dungeoninit();
    }
    Loaded = false;
}

Game::Game() {}

Game::~Game() {}

void Game::init(const char* title, int width, int height, bool fullscreen) {
    int flags = 0;
    if (TTF_Init() == -1) {
        std::cerr << "Failed to initialize SDL_ttf: " << TTF_GetError()
                  << std::endl;
        isRunning = false;
        return;
    }
    font = TTF_OpenFont("assets/fonts/Aerial.ttf", 24);
    pauseFont = TTF_OpenFont("assets/fonts/Aerial.ttf", 72);
    if (!pauseFont) {
        std::cerr << "Failed to load font: " << TTF_GetError() << std::endl;
    }
    if (!font) {
        std::cerr << "Failed to load font: " << TTF_GetError() << std::endl;
    }
    TextureManager::RenderText(font, "Hitpoints: " + std::to_string(life), textColor);
    TextureManager::RenderText(pauseFont, "Paused", textColor);
    if (fullscreen) {
        flags = SDL_WINDOW_FULLSCREEN;
    }

    if (SDL_Init(SDL_INIT_EVERYTHING) == 0) {
        window = SDL_CreateWindow(title, SDL_WINDOWPOS_CENTERED,
                                  SDL_WINDOWPOS_CENTERED, width, height, flags);
        renderer = SDL_CreateRenderer(window, -1, 0);
        isRunning = true;
    }
    Overworldinit();

    srand(time(NULL));
    victoryScreen = TextureManager::LoadTexture("assets/textures/victory.xcf");
    EndGameScreen = TextureManager::LoadTexture("assets/textures/EndGame.png");
    gameOverScreen = TextureManager::LoadTexture("assets/textures/gameover.png");
    mainMenuTexture = TextureManager::LoadTexture("assets/textures/MainMenu.png");
    EndGameScreen = TextureManager::LoadTexture("assets/textures/EndGame.PNG");
    isInnitialized = true;
}

bool just_spawned = false;

void Game::Dungeoninit() {
    map->Bitmap = TextureManager::LoadTexture("assets/textures/Dungeon.png");
    map->checkOverWorld();
    map->AssignRand();
    map->LoadMap();
    map->AssignBorders();
    just_spawned = true;
    std::vector<std::vector<int>> RoomSpawn;
    if (level == 1) {
        player->posx = 56 * 32;
        player->posy = 25 * 32;

        RoomSpawn = {{400, 300},
                     {42 * 32, 30 * 32, 72 * 32, 14 * 32},
                     {72 * 32, 43 * 32, 102 * 32, 50 * 32},
                     {111 * 32, 11 * 32},
                     {14 * 32, 56 * 32, 24 * 32, 65 * 32}};

        // Use the animated texture if needed.
        Level1Pet = new GameObject("assets/textures/cage.png", 300, 300, 64, 64);
    } else if (level == 2) {
        Level1Pet->posx = -100;
        Level1Pet->posy = -100;
        player->posx = 26 * 32;
        player->posy = 22 * 32;
        RoomSpawn = {{12 * 32, 28 * 32, 41 * 32, 28 * 32},
                     {49 * 32, 4 * 32, 72 * 32, 5 * 32},
                     {98 * 32, 13 * 32, 110 * 32, 25 * 32},
                     {61 * 32, 39 * 32},
                     {51 * 32, 53 * 32, 59 * 32, 62 * 32, 98 * 32, 63 * 32,
                      92 * 32, 55 * 32}};
        Level2Pet = new GameObject("assets/textures/cage.png", 71 * 32, 58 * 32, 64, 64);
        Level2Pet->ResetAnimation();
    }
    if (level == 3) {
        Level1Pet->posx = -100;
        Level1Pet->posy = -100;

        Level2Pet->posx = -100;
        Level2Pet->posy = -100;

        player->posx = 16 * 32;
        player->posy = 4 * 32;
        RoomSpawn = {{33 * 32, 5 * 32},
                     {97 * 32, 5 * 32, 105 * 32, 10 * 32},
                     {60 * 32, 23 * 32, 70 * 32, 27 * 32},
                     {14 * 32, 24 * 32, 27 * 32, 28 * 32},
                     {111 * 32, 25 * 32},
                     {20 * 32, 48 * 32, 33 * 32, 53 * 32, 34 * 32, 48 * 32},
                     {66 * 32, 67 * 32, 79 * 32, 64 * 32},
                     {101 * 32, 50 * 32, 107 * 32, 52 * 32}};
        Level3Pet = new GameObject("assets/textures/cage.png", 71 * 32, 65 * 32, 64, 64);
        Level3Pet->ResetAnimation();
    }
    for (const std::vector<int>& room : RoomSpawn) {
        for (size_t i = 0; i < room.size(); i += 2) {
            scientists.insert(new Scientist("assets/textures/scientist.png",
                                            room[i], room[i + 1], 64, 64));
        }
    }
}

void Game::Overworldinit() {
    if (level == 0) {
        player = new Player("assets/textures/Chewbacca.png", 30 * 32, 25 * 32,
                            64, 64);
        map = new Map("assets/textures/overworld.xcf");
    } else {
        // Reposition player regardless of loaded state.
        player->posx = 30 * 32;
        player->posy = 25 * 32;
        map->Bitmap = TextureManager::LoadTexture("assets/textures/overworld.xcf");
        map->checkOverWorld();
        map->AssignRand();
        map->LoadMap();
        map->AssignBorders();

        // Reposition pets if they were not loaded from file.
        if (Level1Pet && level == 1 && !Loaded) {
            Level1Pet->posx = 33 * 32;
            Level1Pet->posy = 19 * 32;
            Level1Pet->ResetAnimation();
        }
        if (Level2Pet && level == 2 && !Loaded) {
            Level2Pet->posx = 33 * 32;
            Level2Pet->posy = 19 * 32;
            Level2Pet->ResetAnimation();
        }
        if (Level3Pet && level == 3 && !Loaded) {
            Level3Pet->posx = 33 * 32;
            Level3Pet->posy = 19 * 32;
            Level3Pet->ResetAnimation();
        }
        if(level == 2 && Loaded){
            Level1Pet->posx = Level1Pet->ShelterX;
            Level1Pet->posy = Level1Pet->ShelterY;
            Level1Pet->objTexture = TextureManager::LoadTexture("assets/textures/hampter.png");
            Level1Pet->FollowPlayer(player);
            if(Level2Pet){
                Level2Pet->posx = Level2Pet->ShelterX;
                Level2Pet->posy = Level2Pet->ShelterY;
                Level2Pet->objTexture = TextureManager::LoadTexture("assets/textures/hampter.png");
                Level2Pet->FollowPlayer(player);
            }
        }
        if(level == 3 && Loaded){
            Level1Pet->posx = Level1Pet->ShelterX;
            Level1Pet->posy = Level1Pet->ShelterY;
            Level1Pet->objTexture = TextureManager::LoadTexture("assets/textures/hampter.png");
            Level1Pet->FollowPlayer(player);
            Level2Pet->posx = Level2Pet->ShelterX;
            Level2Pet->posy = Level2Pet->ShelterY;
            Level2Pet->objTexture = TextureManager::LoadTexture("assets/textures/hampter.png");
            Level2Pet->FollowPlayer(player);
            if(Level3Pet){
                Level3Pet->posx = Level3Pet->ShelterX;
                Level3Pet->posy = Level3Pet->ShelterY;
                Level3Pet->objTexture = TextureManager::LoadTexture("assets/textures/hampter.png");
                Level3Pet->FollowPlayer(player);
            }
        }
    }
}

void Game::handleEvents() {
    SDL_Event event;
    SDL_PollEvent(&event);
    switch (event.type) {
        case SDL_QUIT:
            isRunning = false;
            break;
        case SDL_MOUSEBUTTONDOWN: {
            SDL_Rect mouseRect = {(int)mouse.xpos, (int)mouse.ypos, 1, 1};
            if (MainMenu) {
                // Play button clicked
                if (Collision::AABB(playButton, mouseRect)) {
                    MainMenu = false;  // Start the game
                    RestartGame();
                }
                // Load button clicked
                else if (Collision::AABB(loadButton, mouseRect)) {
                    LoadGame();
                    MainMenu = false;  // Start the game
                } else if (Collision::AABB(settingsButton, mouseRect)) {
                    // settings
                } else if (Collision::AABB(leaderboardButton, mouseRect)) {
                    // leaderboard
                }
            }
        } break;
        case SDL_KEYDOWN:
            if (event.key.keysym.sym == SDLK_r) {
                RestartGame();
            }
            if (event.key.keysym.sym == SDLK_p) {
                Paused = !Paused;
            }
            break;
        default:
            break;
    }
    mouse.XY(event);
    mouse.Clicked(event);
}

int TimeSinceLastBullet = 1e9;
float collisionCooldown = 0;

void Game::update() {
    if (Paused) {
        return;
    }
    std::cout << Paused << std::endl;
    if (!isInnitialized) {
        return;
    }
    if (just_spawned) {
        just_spawned = false;
        return;
    }
    player->Update();
    if (overworld) {
        Overworldupdate();
    } else {
        Dungeonupdate();
    }
    if (lifeTextTexture) SDL_DestroyTexture(lifeTextTexture);

    std::string lifeText = "Hitpoints: " + std::to_string(life);
    lifeTextTexture = TextureManager::RenderText(font, lifeText, textColor);

    if (victory || gameOver || EndGame) {
        return;
    }

    if (life <= 0) {
        gameOver = true;
    }

    Camera.x = static_cast<int>(player->posx) - 1920 / 2;
    Camera.y = static_cast<int>(player->posy) - 1080 / 2;
    int mapWidth = 120 * 32;
    int mapHeight = 72 * 32;
    if (Camera.x < 0) Camera.x = 0;
    if (Camera.y < 0) Camera.y = 0;
    if (Camera.x > (mapWidth - Camera.w)) Camera.x = mapWidth - Camera.w;
    if (Camera.y > (mapHeight - Camera.h)) Camera.y = mapHeight - Camera.h;
}

void Game::Dungeonupdate() {
    for (SDL_Rect Border : map->Borders) {
        player->CollisionDetect(Border);
        for (Scientist* scientist : scientists) {
            scientist->CollisionDetect(Border);
        }
        if (level == 1) {
            Level1Pet->CollisionDetect(Border);
        } else if (level == 2) {
            Level2Pet->CollisionDetect(Border);
        } else if (level == 3) {
            Level3Pet->CollisionDetect(Border);
        }
    }
    if (level == 1) {
        Level1Pet->Update();
    } else if (level == 2) {
        Level2Pet->Update();
    } else if (level == 3) {
        Level3Pet->Update();
    }
    if (level == 1) {
        if (Collision::AABB(player->dest, Level1Pet->dest)) {
            Level1Pet->Follow = true;
            Level1Pet->dest.w = 64;
            Level1Pet->dest.h = 64;
        }
        if (Level1Pet->Follow) {
            Level1Pet->FollowPlayer(player);
        }
    } else if (level == 2) {
        if (Collision::AABB(player->dest, Level2Pet->dest)) {
            Level2Pet->Follow = true;
            Level2Pet->dest.w = 64;
            Level2Pet->dest.h = 64;
        }
        if (Level2Pet->Follow) {
            Level2Pet->FollowPlayer(player);
        }
    } else if (level == 3) {
        if (Collision::AABB(player->dest, Level3Pet->dest)) {
            Level3Pet->Follow = true;
            Level3Pet->dest.w = 64;
            Level3Pet->dest.h = 64;
        }
        if (Level3Pet->Follow) {
            Level3Pet->FollowPlayer(player);
        }
    }

    for (Scientist* scientist : scientists) scientist->Update(player, map);
    if (mouse.click && TimeSinceLastBullet > 750) {
        TimeSinceLastBullet = 0;
        Bullet* bullet = new Bullet("assets/textures/bullet.png", player->posx + 10,
                                      player->posy + 10, 48, 48);
        bullet->Active = true;
        bullet->pos.x = mouse.xpos + Camera.x - player->posx;
        bullet->pos.y = mouse.ypos + Camera.y - player->posy;
        bullet->pos = glm::normalize(bullet->pos);
        bullets.insert(bullet);
    }
    TimeSinceLastBullet += Clock::delta;

    for (Bullet* bullet : bullets) {
        if (bullet != nullptr && bullet->Active) {
            bullet->Update(player);
        }
    }

    for (Bullet* bullet : bullets) {
        for (SDL_Rect Border : map->Borders) {
            SDL_Rect tempBullet{static_cast<int>(bullet->posx), static_cast<int>(bullet->posy),
                                bullet->dest.w, bullet->dest.h};
            if (Collision::AABB(tempBullet, Border)) {
                bullet->Active = false;
            }
        }
    }

    std::vector<Bullet*> toDelete;
    std::set<Scientist*> toDeleteScientist;
    for (Bullet* bullet : bullets) {
        for (Scientist* scientist : scientists) {
            if (Collision::AABB(bullet->dest, scientist->dest)) {
                toDeleteScientist.insert(scientist);
                toDelete.push_back(bullet);
            }
        }
        if (!bullet->Active) {
            toDelete.push_back(bullet);
        }
    }

    for (Bullet* bullet : toDelete) {
        bullets.erase(bullet);
        delete bullet;
    }
    for (Scientist* scientist : toDeleteScientist) {
        scientists.erase(scientist);
        delete scientist;
    }

    collisionCooldown -= Clock::delta;
    for (Scientist* scientist : scientists) {
        SDL_Rect tempPlayer{static_cast<int>(player->posx), static_cast<int>(player->posy),
                            player->dest.w, player->dest.h};
        SDL_Rect tempScientist{static_cast<int>(scientist->posx), static_cast<int>(scientist->posy),
                               scientist->dest.w, scientist->dest.h};

        if (Collision::AABB(tempPlayer, tempScientist)) {
            if (collisionCooldown <= 0) {
                life--;
                collisionCooldown = 1000.0f;
            }
            break;
        }
    }
    if (scientists.empty()) {
        victory = true;
    }
}

void Game::Overworldupdate() {
    if (Level1Pet && Level1Pet->inShelter && Level2Pet &&
        Level2Pet->inShelter && Level3Pet && Level3Pet->inShelter) {
        EndGame = true;
    }
    if (level == 2) {
        // Reposition using the loaded shelter coordinates
        Level1Pet->posx = Level1Pet->ShelterX;
        Level1Pet->posy = Level1Pet->ShelterY;
    }
    if (level == 3) {
        Level1Pet->posx = Level1Pet->ShelterX;
        Level1Pet->posy = Level1Pet->ShelterY;
        Level2Pet->posx = Level2Pet->ShelterX;
        Level2Pet->posy = Level2Pet->ShelterY;
    }
    map->Borders.clear();
    if (Level1Pet) {
        Level1Pet->Update();
        Level1Pet->ShelterDetect();
        Level1Pet->FollowPlayer(player);
    }
    if (Level2Pet) {
        Level2Pet->Update();
        Level2Pet->ShelterDetect();
        Level2Pet->FollowPlayer(player);
    }
    if (Level3Pet) {
        Level3Pet->Update();
        Level3Pet->ShelterDetect();
        Level3Pet->FollowPlayer(player);
    }

    for (SDL_Rect Border : map->OWBorders) {
        player->CollisionDetect(Border);
        if (Level1Pet) Level1Pet->CollisionDetect(Border);
        if (Level2Pet) Level2Pet->CollisionDetect(Border);
        if (Level3Pet) Level3Pet->CollisionDetect(Border);
    }
    if (Level1Pet) player->ShelterDetect();
    SDL_Rect tempPlayer{static_cast<int>(player->posx), static_cast<int>(player->posy),
                        player->dest.w, player->dest.h};
    Tile* playerTile = &map->tile[static_cast<int>(player->posx) / 32][static_cast<int>(player->posy) / 32];
    if (Collision::AABB(tempPlayer, playerTile->dest) &&
        ((map->map[static_cast<int>(player->posx) / 32][static_cast<int>(player->posy) / 32] == '4' ||
          map->map[static_cast<int>(player->posx) / 32][static_cast<int>(player->posy) / 32] == '7') &&
         !playerTile->Used)) {
        if (Level1Pet && Level1Pet->inShelter && level == 1) {
            Level1Pet->ShelterX = Level1Pet->posx;
            Level1Pet->ShelterY = Level1Pet->posy;
            Game::overworld = false;
            playerTile->Used = true;
            level++;
            Dungeoninit();
            return;
        } else if (Level2Pet && Level2Pet->inShelter && Level1Pet &&
                   Level2Pet->inShelter && level == 2) {
            Level1Pet->ShelterX = Level1Pet->posx;
            Level1Pet->ShelterY = Level1Pet->posy;
            Level2Pet->ShelterX = Level2Pet->posx;
            Level2Pet->ShelterY = Level2Pet->posy;

            Game::overworld = false;
            playerTile->Used = true;
            level++;
            Dungeoninit();
            return;
        } else if (Level3Pet && Level3Pet->inShelter && Level2Pet &&
                   Level3Pet->inShelter && Level1Pet && Level1Pet->inShelter &&
                   level == 3) {
            Game::overworld = false;
            playerTile->Used = true;
            level++;
            Dungeoninit();
            return;
        }
        if (level == 0) {
            Game::overworld = false;
            playerTile->Used = true;
            level++;
            Dungeoninit();
            return;
        }
    }
}

void Game::render() {
    SDL_RenderClear(renderer);
    SDL_Rect Fullscreen = {0, 0, 1920, 1080};
    if (MainMenu) {
        // Render the main menu background
        SDL_RenderCopy(renderer, mainMenuTexture, nullptr, nullptr);
    } else if (EndGame) {
        SDL_Rect ContinueButton = {406, 852, 947, 100},
                 mouseRect = {(int)mouse.xpos, (int)mouse.ypos, 1, 1};
        if (Collision::AABB(ContinueButton, mouseRect) && mouse.click) {
            RestartGame();
            MainMenu = true;
        }
        SDL_RenderCopy(renderer, EndGameScreen, nullptr, &Fullscreen);
    } else if (victory) {
        if (victoryScreen) {
            SDL_Rect ContinueButton = {488, 381, 1000, 117},
                     mouseRect = {(int)mouse.xpos, (int)mouse.ypos, 1, 1};
            if (Collision::AABB(ContinueButton, mouseRect) && mouse.click &&
                victory) {
                ContinueGame();
            }
            SDL_RenderCopy(renderer, victoryScreen, nullptr, &Fullscreen);
        } else {
            std::cerr << "Error: victoryScreen texture is null!\n";
        }
    } else if (gameOver) {
        if (gameOverScreen) {
            SDL_RenderCopy(renderer, gameOverScreen, nullptr, &Fullscreen);
        } else {
            std::cerr << "Error: gameOverScreen texture is null!\n";
        }
    } else {
        // Render overworld or dungeon objects.
        if (map) {
            map->Render();
        } else {
            std::cerr << "Error: map is null!\n";
        }

        if (player) {
            player->Render();
        } else {
            std::cerr << "Error: player is null!\n";
        }
        if (Level1Pet) Level1Pet->Render();
        if (Level2Pet) Level2Pet->Render();
        if (Level3Pet) Level3Pet->Render();

        for (Scientist* scientist : scientists) {
            if (scientist) {
                scientist->Render();
            } else {
                std::cerr << "Error: scientist is null!\n";
            }
        }

        for (Bullet* bullet : bullets) {
            if (bullet && bullet->Active) {
                bullet->Render();
            } else if (bullet == nullptr) {
                std::cerr << "Error: bullet is null!\n";
            }
        }

        if (!victory && !gameOver && lifeTextTexture) {
            SDL_Rect lifeRect = {1720, 20, 180, 50};
            SDL_RenderCopy(renderer, lifeTextTexture, nullptr, &lifeRect);
        } else if (!victory && !gameOver) {
            std::cerr << "Warning: lifeTextTexture is null!\n";
        }
    }
    if (Paused) {
        SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 128);
        SDL_RenderFillRect(renderer, &Fullscreen);
        SDL_Texture* pauseTexture = TextureManager::RenderText(pauseFont, "Paused", textColor);
        SDL_Rect pauseRect = {SCREEN_WIDTH / 2 - 200, SCREEN_HEIGHT / 2 - 50, 400, 100};
        SDL_RenderCopy(renderer, pauseTexture, nullptr, &pauseRect);
        SDL_DestroyTexture(pauseTexture);
    }

    SDL_RenderPresent(renderer);
}

void Game::clean() {
    SaveGame();
    if (lifeTextTexture) SDL_DestroyTexture(lifeTextTexture);
    TTF_CloseFont(font);
    TTF_Quit();
    if (victoryScreen) SDL_DestroyTexture(victoryScreen);
    if (gameOverScreen) SDL_DestroyTexture(gameOverScreen);

    SDL_DestroyWindow(window);
    SDL_DestroyRenderer(renderer);
    SDL_Quit();
}
#pragma once

#include "SDL2/SDL.h"
#include "SDL_image.h"
#include <iostream>
#include "SDL_joystick.h"
#include "clock.hpp"
#include "SDL_ttf.h"
class Game
{
public:
	Game();
	~Game();

	void init(const char* title, int width, int height, bool fullscreen);
    void Overworldinit();
    void Dungeoninit();
	void handleEvents();
	void update();
    void Dungeonupdate();
    void Overworldupdate();

	bool running() { return isRunning; }
	void render();
	void clean();
    void RestartGame();
	static SDL_Renderer* renderer;
    static SDL_Rect Camera;
    static bool overworld;
    static int level;
TTF_Font* font;
SDL_Texture* lifeTextTexture = nullptr;
SDL_Color textColor = {255, 255, 255, 255}; // White
SDL_Texture* victoryScreen = nullptr;
SDL_Texture* gameOverScreen = nullptr;
SDL_Texture* pauseScreen = nullptr;
SDL_Texture* mainMenuTexture = nullptr;
SDL_Texture* settingsScreen = nullptr;
SDL_Texture* leaderboardScreen = nullptr;
SDL_Texture* EndGameScreen = nullptr;
static bool gameOver;
static bool victory;
static bool MainMenu;
static bool Paused;
static bool EndGame;

static bool Loaded;
SDL_Rect playButton = {447, 169, 500, 127};
SDL_Rect loadButton = {447, 169 + 203, 500, 127};
SDL_Rect settingsButton = {447, 169 + 2 * 203, 500, 127};
SDL_Rect leaderboardButton = {447, 169 + 3 * 203, 500, 127};
void SaveGame();
void LoadGame();
void ContinueGame();


private:
	bool isRunning = false;
	int cnt = 0;
	SDL_Window* window;
};





#include "GameObject.h"

#include <endian.h>

#include <algorithm>
#include <bit>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <glm/glm.hpp>
#include <glm/vec2.hpp>
#include <iostream>
#include <memory>
#include <ostream>
#include <set>
#include <system_error>

#include "Bullet.hpp"
#include "Collision.hpp"
#include "Game.h"
#include "Mouse.hpp"
#include "SDL_hidapi.h"
#include "SDL_platform.h"
#include "SDL_rect.h"
#include "SDL_render.h"
#include "SDL_stdinc.h"
#include "SDL_timer.h"
#include "TextureManager.h"
#include "clock.hpp"
#include "glm/geometric.hpp"
#include "player.hpp"
GameObject::GameObject(const char* textureSheet, int x, int y, int h, int w) {
	objTexture = TextureManager::LoadTexture(textureSheet);
	SDL_QueryTexture(objTexture, NULL, NULL, &dest.w, &dest.h);
	posx = x;
	posy = y;
	isFlipped = false;
	dest.w = w;
	dest.y = posy;
	dest.x = posx;
	dest.h = h;
	isRunning = false;
	isIdle = true;
	FrameWidth = w;
	FrameHeight = h;
    lastFrameTime = 0;
    CurrentFrame = 0;
	// Set initial srcRect for animation
	srcRect = {0, 0, FrameWidth, FrameHeight};
}

void GameObject::Update() {
	oldX = posx;
	oldY = posy;
	dest.x = posx - Game::Camera.x;
	dest.y = posy - Game::Camera.y;
    Animate();
}



void GameObject::FollowPlayer(GameObject* player) {
    // Stop movement if pet is in the shelter
    if (inShelter) {
        isIdle = true;
        isRunning = false;
        objTexture = idleTexture;
        return; // Prevent any movement update
    }

    isAnimated = true;
    glm::vec2 move = glm::vec2(player->posx - posx, player->posy - posy);
    float distance = glm::length(move);

    // Normalize movement vector if distance is greater than 0
    if (distance > 0) {
        move = glm::normalize(move);
    }

    // Collision detection
    SDL_Rect AnimalDest = {(int)posx, (int)posy, dest.w, dest.h};
    SDL_Rect PlayerDest = {(int)player->posx, (int)player->posy, player->dest.w,
                           player->dest.h};

    if (Collision::AABB(AnimalDest, PlayerDest)) {
        isIdle = true;
        isRunning = false;
        objTexture = idleTexture;
    } else {
        isIdle = false;
        isRunning = true;
        objTexture = runningTexture;
        posx += move.x * 0.2f * Clock::delta;  // Adjust speed as needed
        posy += move.y * 0.2f * Clock::delta;
    }

    // Adjust for camera position
    dest.x = posx - Game::Camera.x;
    dest.y = posy - Game::Camera.y;
}
   void GameObject::ResetAnimation() {
       this->CurrentFrame = 0;
   }
void GameObject::Animate() {
    
    Uint32 currentTime = SDL_GetTicks();
    // Only change the frame if enough time has passed (for smoother animation)
    if (currentTime - lastFrameTime > frameDelay) {
        lastFrameTime = currentTime;

        // Handle animation based on whether the object is running or idle
        if (isRunning || isIdle) {
            CurrentFrame++;
            if (CurrentFrame >= 7)  // Assuming there are 7 frames per animation
                CurrentFrame = 0;

            srcRect.x = CurrentFrame * FrameWidth;  // Update srcRect for the next frame
        }
    }
    
}

void GameObject::CollisionDetect(SDL_Rect Border) {
	SDL_Rect ObjRect = {(int)std::floor(posx), (int)std::floor(posy), 32, 32};
	glm::vec2 oldPos(oldX, oldY);
	float overlapX = std::min((int)posx + dest.w, Border.x + Border.w) -
					 std::max((int)posx, Border.x);
	float overlapY = std::min((int)posy + dest.h, Border.y + Border.h) -
					 std::max((int)posy, Border.y);

	if (overlapX <= 0 || overlapY <= 0) {
		return;
	}

	Collided = true;

	if (overlapX < overlapY) {
		// Horizontal collision (LEFT or RIGHT)
		if (oldPos.x < Border.x) {
			posx -= overlapX;  // Push player back from left collision
		} else {
			posx += overlapX;  // Push player back from right collision
		}
	} else {
		// Vertical collision (TOP or BOTTOM)
		if (oldPos.y < Border.y) {
			posy -= overlapY;  // Push player back from top collision
		} else {
			posy += overlapY;  // Push player back from bottom collision
		}
	}
}

void GameObject::ShelterDetect() {
    SDL_Rect Shelter = {150, 480, 494 - 127, 120}; // Make sure width and height are correct
    SDL_Rect tempDest = {(int)posx, (int)posy, dest.w, dest.h};
    SDL_Rect* ShelterPtr = &Shelter;
    SDL_Rect* tempDestPtr = &tempDest;
    if (SDL_HasIntersection(ShelterPtr,tempDestPtr) && Game::overworld) {
        inShelter = true;

    } else {
        inShelter = false;
    }
}

void GameObject::Render() {
    if(!isAnimated){

	if (!isFlipped)
		SDL_RenderCopyEx(Game::renderer, objTexture, NULL, &dest, 0, NULL,
						 SDL_FLIP_HORIZONTAL);
    
	else
		SDL_RenderCopy(Game::renderer, objTexture, NULL, &dest);
    }
    else{
        SDL_RenderCopy(Game::renderer, objTexture, &srcRect, &dest);
    }
}
#pragma once

#include <sys/ucontext.h>
#include <complex>
#include <ios>
#include <set>
#include "Game.h"
#include "SDL_audio.h"
#include "SDL_mutex.h"
#include "SDL_rect.h"
#include "SDL_render.h"
#include <glm/glm.hpp>
#include "glm/detail/qualifier.hpp"
#include "TextureManager.h"
#include <set>
struct SaveObjectData {
    float posx;
    float posy;
    SDL_Rect dest;
    int shelterX;
    int shelterY;
};
class GameObject {
   public:

       GameObject(){};
	GameObject(const char* textureSheet, int x, int y,int h,int w) ;
//	GameObject(const char* textureSheet, int x, int y, int nFrames, int mSpeed);

	~GameObject() {
        SDL_DestroyTexture(objTexture);
    }
	void Update();
    void FollowPlayer(GameObject* player);
	void Render();
    void Animate();
    void ShelterDetect();
	SDL_Texture* objTexture;
    SDL_Texture* runningTexture= TextureManager::LoadTexture("assets/textures/hampter_running.png");
    SDL_Texture* idleTexture= TextureManager::LoadTexture("assets/textures/hampter.png");
	SDL_Rect srcRect, dest;
	bool moving_left = false, moving_right = false, moving_up = false,
		 moving_down = false;
	bool isFlipped = false;
	bool isAnimated = false;
	int frames = 0;
	int speed = 100;
    bool Collided = false;
	float posx,oldX;
	float posy,oldY; 
    bool Follow = false;
    bool inShelter = false;
int frameDelay = 100;
bool	isRunning;
bool	isIdle;
int	FrameWidth;
int	FrameHeight;
int  lastFrameTime;
int   CurrentFrame;
float ShelterX = 0;
float ShelterY = 0;
static bool Loaded;
    void CollisionDetect(SDL_Rect Border);
SaveObjectData GetSaveData() {
    SaveObjectData data;
    data.posx = posx;
    data.posy = posy;
    data.dest = dest;
    data.shelterX = ShelterX;
    data.shelterY = ShelterY;
    return data;
}
void SetSaveData(SaveObjectData data) {
    posx = data.posx;
    posy = data.posy;
    dest = data.dest;
    ShelterX = data.shelterX;
    ShelterY = data.shelterY;
}
void ResetAnimation();
};

#include <immintrin.h>
#include <cmath>
#include "SDL.h"
#include "SDL_rect.h"
#include "TextureManager.h"
#include "Tile.hpp"
#include<vector>
class Map {
public:
    std::vector<SDL_Rect> Borders;
    std::vector<SDL_Rect> OWBorders;
    SDL_Texture* Bitmap;
    char map[120][72];
     Tile tile[120][72];
     /*
    SDL_Rect tile1 = {0,0,32,32};
    SDL_Rect tile2 = {128,0,32,32};
    */
     SDL_Rect tile1;
    SDL_Rect tile2;
    SDL_Rect tile3;
    SDL_Rect tile4;
    SDL_Rect tile5;
    SDL_Rect tile6;
    SDL_Rect tile7;
    SDL_Rect tile8;
    SDL_Rect tile9;
    SDL_Rect tile10;


    Map(const char *a){
       Bitmap = TextureManager::LoadTexture(a);

    checkOverWorld();
    AssignRand();
    LoadMap();
    AssignBorders();
    };
    void AssignRand();
    void LoadMap();
    void Render();
    void AssignBorders();
    void checkOverWorld();

};

#include "Map.hpp"

#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iostream>
#include <iterator>

#include "SDL_render.h"
#include "glm/detail/type_half.hpp"
void Map::AssignRand() {
	if (!Game::overworld) {
		if (Game::level == 1) {
			std::ifstream file("assets/Levels/Level1.txt");
			char type;
			for (int y = 0; y < 72; y++) {
				for (int x = 0; x < 120; x++) {
					file >> type;
					map[x][y] = type;
				}
			}
		}
		if (Game::level == 2) {
			std::ifstream file("assets/Levels/Level2.txt");
			char type;
			for (int y = 0; y < 72; y++) {
				for (int x = 0; x < 120; x++) {
					file >> type;
					map[x][y] = type;
				}
			}
		}
		if (Game::level == 3) {
			std::ifstream file("assets/Levels/Level3.txt");
			char type;
			for (int y = 0; y < 72; y++) {
				for (int x = 0; x < 120; x++) {
					file >> type;
					map[x][y] = type;
				}
			}
		}
	} else {
		std::ifstream file("assets/overworld.txt");
		char type;
		for (int y = 0; y < 72; y++) {
			for (int x = 0; x < 120; x++) {
				file >> type;
				map[x][y] = type;
			}
		}
	}
}
void Map::AssignBorders() {
	if (!Game::overworld) {
		for (int y = 0; y < 72; y++) {
			for (int x = 0; x < 120; x++) {
				if (map[x][y] == '2') {
					if (map[x + 1][y] != '2' || map[x - 1][y] != '2' ||
						map[x][y + 1] != '2' || map[x][y - 1] != '2') {
						Borders.push_back(tile[x][y].dest);
						tile[x][y].isWall = true;
					}
				}
			}
		}
	} else {
		for (int y = 0; y < 72; y++) {
			for (int x = 0; x < 120; x++) {
				if (map[x][y] == '5') {
					if (map[x + 1][y] != '5' || map[x - 1][y] != '5' ||
						map[x][y + 1] != '5' || map[x][y - 1] != '5') {
						OWBorders.push_back(tile[x][y].dest);
						tile[x][y].isWall = true;
					}
				}
				if (map[x][y] == '3') {
					if (map[x + 1][y] != '3' || map[x - 1][y] != '3' ||
						map[x][y + 1] != '3' || map[x][y - 1] != '3') {
						OWBorders.push_back(tile[x][y].dest);
						tile[x][y].isWall = true;
					}
				}
                if(map[x][y] == '8'){
                    if (map[x + 1][y] != '8' || map[x - 1][y] != '8' ||
                            map[x][y + 1] != '8' || map[x][y - 1] != '8') {
                        OWBorders.push_back(tile[x][y].dest);
                        tile[x][y].isWall = true;
                    }
                }


				/*
				if (map[x][y] == '4') {
					if (map[x + 1][y] != '4' || map[x - 1][y] != '4' ||
						map[x][y + 1] != '4' || map[x][y - 1] != '4') {
						OWBorders.push_back(tile[x][y].dest);
						tile[x][y].isWall = true;

					}

				}
				*/
			}
		}
	}
}
void Map::LoadMap() {
	for (int y = 0; y < 72; y++) {
		for (int x = 0; x < 120; x++) {
			tile[x][y].dest.x = x * 32;
			tile[x][y].dest.y = y * 32;
			tile[x][y].dest.w = 32;
			tile[x][y].dest.h = 32;
			tile[x][y].posx = tile[x][y].dest.x;
			tile[x][y].posy = tile[x][y].dest.y;
		}
	}
}
void Map::checkOverWorld() {
	if (!Game::overworld) {
		tile1 = {32, 0, 32, 32};
		tile2 = {32, 64, 32, 32};

	} else {
		tile1 = {0, 271, 32, 32};	 // normal grass
		tile2 = {0, 298, 32, 32};	 // grass z rozicami
		tile3 = {209, 263, 32, 32};	 // gozd
		tile4 = {121, 633, 32, 32};	 // dungeon door
		tile7 = {421, 754, 32, 32};	 // dungeon second door
		tile5 = {211, 720, 32, 32};	 // dungeon wall
		tile6 = {30, 569, 32, 32};	 // dungeon roof
        tile8 = {211,836,32,32}; //center za zivalce walls
        tile9 = {30,809,32,32}; //center za zivalce roof
        tile10 = {121,754,32,32}; //center za zivalce door 
	}
}

void Map::Render() {
	int OffsetX = Game::Camera.x / 32;
	int OffsetY = Game::Camera.y / 32;

	int pixelOffsetX = Game::Camera.x % 32;	 // Sub-tile offset
	int pixelOffsetY = Game::Camera.y % 32;	 // Sub-tile offset

	int maxX = std::min(OffsetX + 61,
						120);  // +1 to prevent gaps at screen edges
	int maxY = std::min(OffsetY + 35, 72);

	for (int y = OffsetY; y < maxY; y++) {
		for (int x = OffsetX; x < maxX; x++) {
			char tileType = map[x][y];

			// Calculate screen position with smooth pixel offset
			SDL_Rect dest = {(x - OffsetX) * 32 - pixelOffsetX,
							 (y - OffsetY) * 32 - pixelOffsetY, 32, 32};

			switch (tileType) {
				case '1':
					SDL_RenderCopy(Game::renderer, Bitmap, &tile1, &dest);
					break;
				case '2':
					SDL_RenderCopy(Game::renderer, Bitmap, &tile2, &dest);
					break;
				case '3':
					SDL_RenderCopy(Game::renderer, Bitmap, &tile3, &dest);
					break;
				case '4':
					SDL_RenderCopy(Game::renderer, Bitmap, &tile4, &dest);
					break;
				case '5':
					SDL_RenderCopy(Game::renderer, Bitmap, &tile5, &dest);
					break;
				case '6':
					SDL_RenderCopy(Game::renderer, Bitmap, &tile6, &dest);
					break;
				case '7':
					SDL_RenderCopy(Game::renderer, Bitmap, &tile7, &dest);
                    break;
                case '8':
                    SDL_RenderCopy(Game::renderer, Bitmap, &tile8, &dest);
                    break;
                case '9':
                    SDL_RenderCopy(Game::renderer, Bitmap, &tile9, &dest);
                    break;
                case '0':
                    SDL_RenderCopy(Game::renderer, Bitmap, &tile10, &dest);
                    break;
				default:
					break;	// Skip empty tiles or unknown types
			}
		}
	}
#include "player.hpp"
#include "Collision.hpp"
#include <algorithm>
#include "glm/detail/qualifier.hpp"
void Player:: Render(){
	if (!isFlipped)
		SDL_RenderCopyEx(Game::renderer, objTexture, NULL, &dest, 0, NULL,
						 SDL_FLIP_HORIZONTAL);
	else
		SDL_RenderCopy(Game::renderer, objTexture, NULL, &dest);

}



#include "GameObject.h"
#include "SDL_rwops.h"
#include "glm/integer.hpp"
#include <glm/glm.hpp>
class Player : public GameObject {
    public:
        glm::vec2 delta;
    Player(const char* textureSheet, int x, int y, int h, int w) : GameObject(textureSheet, x, y, h, w) {}
    void Update() {
    
	const Uint8* state = SDL_GetKeyboardState(NULL);
	moving_left = state[SDL_SCANCODE_A];
	moving_up = state[SDL_SCANCODE_W];
	moving_down = state[SDL_SCANCODE_S];
	moving_right = state[SDL_SCANCODE_D];
	glm::vec2 move;
    oldX = posx;
    oldY = posy;
	move.x = 0;
	move.y = 0;
	if (moving_up) move.y -= 1 * Clock::delta * 0.5;
	if (moving_down) move.y += 1 * Clock::delta * 0.5;
	if (moving_right) {
		move.x += 1 * Clock::delta * 0.5;
		isFlipped = true;
	}
	if (moving_left) {
		move.x -= 1 * Clock::delta * 0.5;
		isFlipped = false;
	}
    if(moving_up && moving_right || moving_up && moving_left || moving_down && moving_right || moving_down && moving_left){
        move.x /= 1.414;
       move.y /= 1.414;
    }
    posx += move.x;
    posy += move.y;
    dest.x = posx-Game::Camera.x;
    dest.y = posy-Game::Camera.y;
    
    if(posx<0){
        posx = 0; 
    }
    if(posy<0){
        posy = 0;
    }
    if(posx>120*32-dest.w){
        posx = 120*32-dest.w;
    }
    if(posy>72*32-dest.h){
        posy = 72*32-dest.h;
    }
    }
    void Render();



};
#include "Scientist.hpp"

#include <cctype>
#include <cstdlib>	// For rand()
#include <ctime>	// For seeding rand()
#include <experimental/filesystem>
#include <functional>
#include <glm/glm.hpp>
#include <glm/vec2.hpp>
#include <type_traits>

#include "Collision.hpp"
#include "Game.h"
#include "GameObject.h"
#include "SDL_render.h"



bool Scientist::HasLineOfSight(GameObject* player, Map* map) {
    const float stepSize = 5.0f;  
    glm::vec2 direction = glm::normalize(glm::vec2(player->posx - posx, player->posy - posy));
    glm::vec2 currentPos = glm::vec2(posx, posy);

    while (glm::length(currentPos - glm::vec2(player->posx, player->posy)) > stepSize) {
        currentPos += direction * stepSize;

        SDL_Rect CheckRect = {
            (int)currentPos.x, (int)currentPos.y, dest.w, dest.h
        };

        for ( SDL_Rect& Border : map->Borders) {
            if (Collision::AABB(CheckRect, Border)) {
                return false;  // Wall blocks view
            }
        }
    }
    return true;  
}


void Scientist::Update( GameObject* player, Map* map) {
    glm::vec2 move = glm::vec2(player->posx - posx, player->posy - posy);
    float distance = glm::length(move);
    bool CanSeePlayer = (distance < 750) && HasLineOfSight(player, map);

    float movementSpeed = Clock::delta * 0.15f;
    glm::vec2 newPos = glm::vec2(posx, posy);  

    if (CanSeePlayer) {
    if (distance > 0.1f) {  
            glm::vec2 Finalmove = glm::normalize(move);
            newPos += Finalmove * movementSpeed;
        }
    isFlipped = (move.x > 0);
    } else {
        // Handle Random Movement
        randomMoveTime -= Clock::delta;

        if (randomMoveTime <= 0) {
            randomMoveTime = (rand() % 3 + 2) * 1000;  
            float angle = (rand() % 360) * (3.14159265f / 180.0f);
            randomDirection = glm::vec2(cos(angle), sin(angle));
        }

        newPos += randomDirection * movementSpeed * 0.7f;
    }

    // Check for collisions BEFORE updating position
    SDL_Rect FutureRect = { (int)newPos.x, (int)newPos.y, dest.w, dest.h };
    bool isColliding = false;

    for ( SDL_Rect& Border : map->Borders) {
        if (Collision::AABB(FutureRect, Border)) {
            isColliding = true;
            break;
        }
    }

    if (!isColliding) {
        posx = newPos.x;
        posy = newPos.y;
    } else {
        if (!CanSeePlayer) {
            // If random movement collides, pick a new direction immediately
            float angle = (rand() % 360) * (3.14159265f / 180.0f);
            randomDirection = glm::vec2(cos(angle), sin(angle));
            newPos = glm::vec2(posx, posy) + randomDirection * movementSpeed * 0.7f;
        } else {
            // If chasing player but colliding, try slight movement adjustment
            newPos = glm::vec2(posx, posy) + glm::normalize(glm::vec2(rand() % 2 - 1, rand() % 2 - 1)) * movementSpeed * 0.5f;
        }
    }

    // Final collision check
    FutureRect = { (int)newPos.x, (int)newPos.y, dest.w, dest.h };
    bool finalCollision = false;
    for ( SDL_Rect& Border : map->Borders) {
        if (Collision::AABB(FutureRect, Border)) {
            finalCollision = true;
            break;
        }
    }

    if (!finalCollision) {
        posx = newPos.x;
        posy = newPos.y;
    }

    // Update rendering position
    dest.x = posx - Game::Camera.x;
    dest.y = posy - Game::Camera.y;
}

    

    

}

#include "Scientist.hpp"

#include <cctype>
#include <cstdlib>	// For rand()
#include <ctime>	// For seeding rand()
#include <experimental/filesystem>
#include <functional>
#include <glm/glm.hpp>
#include <glm/vec2.hpp>
#include <type_traits>

#include "Collision.hpp"
#include "Game.h"
#include "GameObject.h"
#include "SDL_render.h"



bool Scientist::HasLineOfSight(GameObject* player, Map* map) {
    const float stepSize = 5.0f;  
    glm::vec2 direction = glm::normalize(glm::vec2(player->posx - posx, player->posy - posy));
    glm::vec2 currentPos = glm::vec2(posx, posy);

    while (glm::length(currentPos - glm::vec2(player->posx, player->posy)) > stepSize) {
        currentPos += direction * stepSize;

        SDL_Rect CheckRect = {
            (int)currentPos.x, (int)currentPos.y, dest.w, dest.h
        };

        for ( SDL_Rect& Border : map->Borders) {
            if (Collision::AABB(CheckRect, Border)) {
                return false;  // Wall blocks view
            }
        }
    }
    return true;  
}


void Scientist::Update( GameObject* player, Map* map) {
    glm::vec2 move = glm::vec2(player->posx - posx, player->posy - posy);
    float distance = glm::length(move);
    bool CanSeePlayer = (distance < 750) && HasLineOfSight(player, map);

    float movementSpeed = Clock::delta * 0.15f;
    glm::vec2 newPos = glm::vec2(posx, posy);  

    if (CanSeePlayer) {
    if (distance > 0.1f) {  
            glm::vec2 Finalmove = glm::normalize(move);
            newPos += Finalmove * movementSpeed;
        }
    isFlipped = (move.x > 0);
    } else {
        // Handle Random Movement
        randomMoveTime -= Clock::delta;

        if (randomMoveTime <= 0) {
            randomMoveTime = (rand() % 3 + 2) * 1000;  
            float angle = (rand() % 360) * (3.14159265f / 180.0f);
            randomDirection = glm::vec2(cos(angle), sin(angle));
        }

        newPos += randomDirection * movementSpeed * 0.7f;
    }

    // Check for collisions BEFORE updating position
    SDL_Rect FutureRect = { (int)newPos.x, (int)newPos.y, dest.w, dest.h };
    bool isColliding = false;

    for ( SDL_Rect& Border : map->Borders) {
        if (Collision::AABB(FutureRect, Border)) {
            isColliding = true;
            break;
        }
    }

    if (!isColliding) {
        posx = newPos.x;
        posy = newPos.y;
    } else {
        if (!CanSeePlayer) {
            // If random movement collides, pick a new direction immediately
            float angle = (rand() % 360) * (3.14159265f / 180.0f);
            randomDirection = glm::vec2(cos(angle), sin(angle));
            newPos = glm::vec2(posx, posy) + randomDirection * movementSpeed * 0.7f;
        } else {
            // If chasing player but colliding, try slight movement adjustment
            newPos = glm::vec2(posx, posy) + glm::normalize(glm::vec2(rand() % 2 - 1, rand() % 2 - 1)) * movementSpeed * 0.5f;
        }
    }

    // Final collision check
    FutureRect = { (int)newPos.x, (int)newPos.y, dest.w, dest.h };
    bool finalCollision = false;
    for ( SDL_Rect& Border : map->Borders) {
        if (Collision::AABB(FutureRect, Border)) {
            finalCollision = true;
            break;
        }
    }

    if (!finalCollision) {
        posx = newPos.x;
        posy = newPos.y;
    }

    // Update rendering position
    dest.x = posx - Game::Camera.x;
    dest.y = posy - Game::Camera.y;
}

#pragma once
#include "Game.h"
#include "GameObject.h"
#include "SDL_keyboard.h"
#include <glm/glm.hpp>
#include "Map.hpp"
#include "glm/ext/scalar_int_sized.hpp"
#include "glm/ext/vector_float2.hpp"
class Scientist :public GameObject{
    float randomMoveTime;
    glm::vec2 randomDirection;
    public:
        glm::vec2 delta;
     void Update(GameObject *,Map* );
     Scientist(const char* a,int x,int y,int h,int w):GameObject(a,x,y,h,w){
    randomMoveTime = (rand() % 3 + 2) * 1000;  // Random start time (2-5 sec)
    float angle = (rand() % 360) * (3.14159265f / 180.0f);  // Random angle
    randomDirection = glm::vec2(cos(angle), sin(angle));
     };
     bool HasLineOfSight(GameObject* player,Map* map);
};
#include "Tile.hpp"
bool Tile::IsOffScreen(){
    if(dest.x + dest.w < 0 || dest.x > 1920 || dest.y + dest.h < 0 || dest.y > 1080){
        return true;
    }
    return false;
}

#include <ios>
#include <SDL2/SDL.h>
#include "GameObject.h"
class Tile :public GameObject{
    public:
        bool isRendered=false;
        bool IsOffScreen();
        bool isWall=false;
        bool Used = false;
};

